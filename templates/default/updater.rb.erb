require 'sinatra'
require 'json'
require 'rubygems'
require 'mixlib/shellout'
require 'slack-notifier'
# require 'awesome_print'

%w{
  CHEF_REPO_DIR
  KNIFE_NODE_NAME
  KNIFE_CLIENT_KEY
  KNIFE_VALIDATION_CLIENT_NAME
  KNIFE_VALIDATION_CLIENT_KEY
}.each do |env_var|
  if ENV[env_var].nil?
    fail "#{env_var} required but not set"
  else
    puts "#{env_var}=#{ENV[env_var]}"
  end
end

configure do
  set :port, '<%= node['chefgithook']['sinatra']['port'] %>'
  set :bind, '0.0.0.0'
end

post '/' do
  push = JSON.parse(params[:payload])
  
  request.body.rewind
  body = request.body.read
  verify?(body, request.env['HTTP_X_HUB_SIGNATURE']) unless ENV['CHEFGITHOOK_SECRET'].empty?
  
  ChefGithubHook.sync_to(push)
end

def verify?(payload_body, presented_signature) 
  signature = 'sha1=' + OpenSSL::HMAC.hexdigest(OpenSSL::Digest.new('sha1'), ENV['CHEFGITHOOK_SECRET'], payload_body)
  return halt 401, "Signatures didn't match! #{ENV['CHEFGITHOOK_SECRET']} #{signature} #{presented_signature}" unless Rack::Utils.secure_compare(signature, presented_signature)
end

# ChefGithubHook
class ChefGithubHook
  class << self
    def chef_repo_cmd(cmd)
      command = Mixlib::ShellOut.new(cmd)
      command.cwd = ENV['CHEF_REPO_DIR']
      puts '* Running command:'
      puts "  #{cmd}"
      command.run_command
      command.error!

      [command.stdout, command.stderr]
    end

    def parse_commits(commits)
      modified_files = []

      commits.each do |commit|
        modified_files += commit['added'] + commit['modified']
        modified_files -= commit['removed']
      end

      modified_files.uniq
    end

    def slack
      @slack ||= begin
        Slack::Notifier.new '<%= @slack_webhook_url %>'
      end
    end

    def notify(msg, options = {})
      args = { icon_url: 'http://ops.evertrue.com.s3.amazonaws.com/public/chef_logo.png' }
      color = options[:status] || 'none'
      if options[:files]
        msg += "\n\nFiles uploaded:\n"
        msg += options[:files].map { |f| "- #{f}" }.join("\n")
      end
      args[:attachments] = [{ text: msg, fallback: msg, color: color }]
      puts "* Sending to Slack: #{msg}"
      slack.ping '', args
    end

    def sync_to(push)
      unless push['ref'] == 'refs/heads/master'
        noyify "Ignoring update to #{push['ref']}"
        return
      end
      puts '* Pulling changes from origin master'
      chef_repo_cmd('git pull origin master')
      puts "* Checking out #{push['after']}"
      chef_repo_cmd("git checkout #{push['after']}")
      puts '* Updating Chef Server'
      modified_files = parse_commits(push['commits'])
      puts "* Modified files: #{modified_files.join(', ')}"
      modified_files.each do |modified_file|
        begin
          chef_repo_cmd('/opt/chef/bin/knife upload -c ' +
            "#{ENV['CHEF_REPO_DIR']}/chef-config/knife.rb \"#{modified_file}\"")
        rescue Mixlib::ShellOut::ShellCommandFailed => e
          notify "Uploading of \"#{modified_file}\" failed" \
                 " (#{e.message})", status: 'danger'
        rescue => e
          notify "Got unhandled error handling #{modified_file}" \
                 "#{e.class}/#{e.message}",
                 status: 'danger'
        end
      end
      notify "Pushed hash " \
        "<https://github.com/<%= node['chefgithook']['chef_repo'] %>/commit/#{push['after']}|" \
        "#{push['after'][1..7]}> to Chef.",
        status: 'good',
        files: modified_files
      puts '* Sync complete.'
    rescue => e
      notify "Unhandled exception: #{e.class}/#{e.message}", status: 'danger'
    end
  end
end
