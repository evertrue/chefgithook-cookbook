require 'sinatra'
require 'json'
require 'rubygems'
require 'mixlib/shellout'
require 'slack-notifier'
require 'vault'
# require 'awesome_print'

CHEF_DIRS = %w{data_bags environments roles}

%w{
  CHEF_REPO_DIR
  KNIFE_CHEF_SERVER
  KNIFE_NODE_NAME
  KNIFE_CLIENT_KEY
  KNIFE_VALIDATION_CLIENT_NAME
  KNIFE_VALIDATION_CLIENT_KEY
  VAULT_WORKER_TOKEN
}.each do |env_var|
  if ENV[env_var].nil?
    fail "#{env_var} required but not set"
  else
    puts "#{env_var}=#{ENV[env_var]}"
  end
end

configure do
  set :port, '<%= node['chefgithook']['sinatra']['port'] %>'
  set :bind, '0.0.0.0'
end

options '/status' do
  status 204 && return
end

post '/' do
  push = JSON.parse(params[:payload])

  request.body.rewind
  body = request.body.read
  verify?(body, request.env['HTTP_X_HUB_SIGNATURE']) unless ENV['CHEFGITHOOK_SECRET'].empty?

  ChefGithubHook.sync_to(push)
end

def verify?(payload_body, presented_signature)
  signature = 'sha1=' + OpenSSL::HMAC.hexdigest(OpenSSL::Digest.new('sha1'), ENV['CHEFGITHOOK_SECRET'], payload_body)
  return halt 401, "Signatures didn't match! #{ENV['CHEFGITHOOK_SECRET']} #{signature} #{presented_signature}" unless Rack::Utils.secure_compare(signature, presented_signature)
end

# ChefGithubHook
class ChefGithubHook
  class << self
    def chef_repo_cmd(cmd)
      command = Mixlib::ShellOut.new(cmd)
      command.cwd = ENV['CHEF_REPO_DIR']
      puts '* Running command:'
      puts "  #{cmd}"
      command.run_command
      command.error!

      [command.stdout, command.stderr]
    end

    def parse_commits(commits)
      modified_files = []

      commits.each do |commit|
        modified_files += commit['added'] + commit['modified']
        modified_files -= commit['removed']
      end

      modified_files.uniq
    end

    def slack
      @slack ||= begin
        Slack::Notifier.new '<%= @slack_webhook_url %>'
      end
    end

    def notify(msg, options = {})
      args = { icon_url: 'http://ops.evertrue.com.s3.amazonaws.com/public/chef_logo.png' }
      color = options[:status] || 'none'
      if options[:files]
        msg += "\n\nFiles uploaded:\n"
        msg += options[:files].map { |f| "- #{f}" }.join("\n")
      end
      args[:attachments] = [{ text: msg, fallback: msg, color: color }]
      puts "* Sending to Slack: #{msg}"
      slack.ping '', args
    end

    def modified_file_type(modified_file)
      parent_dir = modified_file.split('/').first
      if CHEF_DIRS.include? parent_dir
        :chef
      elsif parent_dir == 'vault' && modified_file.split('/')[2] == 'policies'
        :vault_policy
      end
    end

    def chef_upload(modified_file)
      chef_repo_cmd('/opt/chef/bin/knife upload -c ' +
        "#{ENV['CHEF_REPO_DIR']}/chef-config/knife.rb \"#{modified_file}\"")
    end

    def vault_policy_upload(modified_file)
      vault_env = modified_file.split('/')[1]
      policy_file = modified_file.split('/').last
      policy_name = policy_file.gsub(/\.json|\.hcl/, '')
      rules = File.read "#{ENV['CHEF_REPO_DIR']}/#{modified_file.chomp}"

      vault = Vault::Client.new(
        address: "http://vault.service.#{vault_env}-us-east-1.consul:8200",
        token: ENV['VAULT_WORKER_TOKEN']
        timeout: 5
      )
      vault.sys.put_policy policy_name, rules
    end

    def sync_to(push)
      unless push['ref'] == 'refs/heads/master'
        notify "Ignoring update to #{push['ref']}"
        return
      end
      puts '* Pulling changes from origin master'
      chef_repo_cmd('git pull origin master')
      puts "* Checking out #{push['after']}"
      chef_repo_cmd("git checkout #{push['after']}")
      modified_files = parse_commits(push['commits'])
      puts "* Modified files: #{modified_files.join(', ')}"
      ignored_files = []
      uploaded_files = []
      modified_files.each do |modified_file|
        begin
          case modified_file_type modified_file
          when :chef
            chef_upload modified_file
            uploaded_files << modified_file
          when :vault_policy
            vault_policy_upload modified_file
            uploaded_files << modified_file
          else
            ignored_files << modified_file
          end
        rescue Mixlib::ShellOut::ShellCommandFailed => e
          notify "Uploading of \"#{modified_file}\" failed" \
                 " (#{e.message})", status: 'danger'
        rescue => e
          notify "Got unhandled error handling #{modified_file}" \
                 "#{e.class}/#{e.message}",
                 status: 'danger'
        end
      end
      if uploaded_files.any?
        notify "Uploaded hash " \
          "<https://github.com/<%= node['chefgithook']['chef_repo'] %>/commit/#{push['after']}|" \
          "#{push['after'][1..7]}>",
          status: 'good',
          files: uploaded_files
      end
      notify 'Ignored files', status: 'none', files: ignored_files if ignored_files.any?
      puts '* Sync complete.'
    rescue => e
      notify "Unhandled exception: #{e.class}/#{e.message}", status: 'danger'
    end
  end
end
